{
    "sourceFile": "src/main/java/com/example/FileController.java",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1743263565063,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1743322207328,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,15 +1,17 @@\n package com.example;\r\n \r\n+import java.nio.file.Files;\r\n+import java.nio.file.Path;\r\n+import java.nio.file.Paths;\r\n+\r\n import org.springframework.beans.factory.annotation.Value;\r\n import org.springframework.stereotype.Controller;\r\n import org.springframework.ui.Model;\r\n-import org.springframework.web.bind.annotation.*;\r\n+import org.springframework.web.bind.annotation.GetMapping;\r\n+import org.springframework.web.bind.annotation.PostMapping;\r\n+import org.springframework.web.bind.annotation.RequestParam;\r\n import org.springframework.web.multipart.MultipartFile;\r\n-import java.nio.file.Files;\r\n-import java.nio.file.Path;\r\n-import java.nio.file.Paths;\r\n-import java.io.IOException;\r\n \r\n @Controller\r\n public class FileController {\r\n     private String secretKey;\r\n"
                },
                {
                    "date": 1743538610409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,8 +2,10 @@\n \r\n import java.nio.file.Files;\r\n import java.nio.file.Path;\r\n import java.nio.file.Paths;\r\n+import java.io.IOException;\r\n+import java.util.Arrays;\r\n \r\n import org.springframework.beans.factory.annotation.Value;\r\n import org.springframework.stereotype.Controller;\r\n import org.springframework.ui.Model;\r\n@@ -19,8 +21,11 @@\n     \r\n     @Value(\"${file.upload-dir}\")\r\n     private String uploadDir;\r\n \r\n+    @Value(\"${spring.servlet.multipart.max-file-size}\")\r\n+    private String maxFileSize;\r\n+\r\n     @GetMapping(\"/\")\r\n     public String home(Model model) {\r\n         model.addAttribute(\"key\", secretKey != null ? secretKey : \"Chưa có khóa\");\r\n         model.addAttribute(\"keySize\", keySize);\r\n@@ -46,79 +51,137 @@\n     }\r\n \r\n     @PostMapping(\"/encrypt\")\r\n     public String encryptFile(@RequestParam(\"file\") MultipartFile file, Model model) {\r\n+        Path tempFile = null;\r\n+        Path encryptedFile = null;\r\n+        \r\n         try {\r\n             if (secretKey == null) {\r\n                 model.addAttribute(\"error\", \"Vui lòng tạo khóa trước!\");\r\n                 return \"index\";\r\n             }\r\n \r\n+            // Validate file size\r\n+            if (file.getSize() > parseMaxFileSize()) {\r\n+                model.addAttribute(\"error\", \"File quá lớn. Kích thước tối đa là \" + maxFileSize);\r\n+                return \"index\";\r\n+            }\r\n+\r\n+            // Validate file name\r\n+            String originalFilename = file.getOriginalFilename();\r\n+            if (originalFilename == null || originalFilename.contains(\"..\")) {\r\n+                model.addAttribute(\"error\", \"Tên file không hợp lệ\");\r\n+                return \"index\";\r\n+            }\r\n+\r\n             Path uploadPath = Paths.get(uploadDir);\r\n             if (!Files.exists(uploadPath)) {\r\n                 Files.createDirectories(uploadPath);\r\n             }\r\n \r\n-            String originalFilename = file.getOriginalFilename();\r\n-            Path filePath = uploadPath.resolve(originalFilename);\r\n-            file.transferTo(filePath);\r\n+            // Save uploaded file temporarily\r\n+            tempFile = uploadPath.resolve(originalFilename);\r\n+            file.transferTo(tempFile);\r\n \r\n-            // Đọc file và mã hóa\r\n-            byte[] fileContent = Files.readAllBytes(filePath);\r\n+            // Read and encrypt file\r\n+            byte[] fileContent = Files.readAllBytes(tempFile);\r\n             AES aes = new AES(secretKey);\r\n             String encryptedContent = aes.encryptFile(fileContent);\r\n             \r\n-            // Lưu file đã mã hóa\r\n+            // Save encrypted file\r\n             String encryptedFilename = \"encrypted_\" + originalFilename;\r\n-            Path encryptedFile = uploadPath.resolve(encryptedFilename);\r\n+            encryptedFile = uploadPath.resolve(encryptedFilename);\r\n             Files.write(encryptedFile, encryptedContent.getBytes());\r\n \r\n             model.addAttribute(\"message\", \"Mã hóa thành công: \" + encryptedFilename + \r\n                 \" | Thời gian: \" + aes.getEncryptionTime() + \" ns\");\r\n             model.addAttribute(\"filePath\", encryptedFile.toAbsolutePath().toString());\r\n \r\n+        } catch (IOException e) {\r\n+            model.addAttribute(\"error\", \"Lỗi khi xử lý file: \" + e.getMessage());\r\n+            e.printStackTrace();\r\n         } catch (Exception e) {\r\n             model.addAttribute(\"error\", \"Lỗi khi mã hóa: \" + e.getMessage());\r\n             e.printStackTrace();\r\n+        } finally {\r\n+            // Clean up temporary file\r\n+            if (tempFile != null && Files.exists(tempFile)) {\r\n+                try {\r\n+                    Files.delete(tempFile);\r\n+                } catch (IOException e) {\r\n+                    e.printStackTrace();\r\n+                }\r\n+            }\r\n         }\r\n         return \"index\";\r\n     }\r\n \r\n     @PostMapping(\"/decrypt\")\r\n     public String decryptFile(@RequestParam(\"file\") MultipartFile file, Model model) {\r\n+        Path tempFile = null;\r\n+        Path decryptedFile = null;\r\n+        \r\n         try {\r\n             if (secretKey == null) {\r\n                 model.addAttribute(\"error\", \"Vui lòng tạo khóa trước!\");\r\n                 return \"index\";\r\n             }\r\n \r\n+            // Validate file size\r\n+            if (file.getSize() > parseMaxFileSize()) {\r\n+                model.addAttribute(\"error\", \"File quá lớn. Kích thước tối đa là \" + maxFileSize);\r\n+                return \"index\";\r\n+            }\r\n+\r\n+            // Validate file name\r\n+            String originalFilename = file.getOriginalFilename();\r\n+            if (originalFilename == null || originalFilename.contains(\"..\")) {\r\n+                model.addAttribute(\"error\", \"Tên file không hợp lệ\");\r\n+                return \"index\";\r\n+            }\r\n+\r\n             Path uploadPath = Paths.get(uploadDir);\r\n             if (!Files.exists(uploadPath)) {\r\n                 Files.createDirectories(uploadPath);\r\n             }\r\n \r\n-            String originalFilename = file.getOriginalFilename();\r\n-            Path filePath = uploadPath.resolve(originalFilename);\r\n-            file.transferTo(filePath);\r\n+            // Save uploaded file temporarily\r\n+            tempFile = uploadPath.resolve(originalFilename);\r\n+            file.transferTo(tempFile);\r\n \r\n-            // Đọc file đã mã hóa\r\n-            String encryptedContent = new String(Files.readAllBytes(filePath));\r\n+            // Read encrypted content\r\n+            byte[] encryptedBytes = Files.readAllBytes(tempFile);\r\n+            String encryptedContent = new String(encryptedBytes, \"UTF-8\");\r\n             \r\n+            // Decrypt content\r\n             AES aes = new AES(secretKey);\r\n             byte[] decryptedContent = aes.decryptFile(encryptedContent);\r\n             \r\n-            // Lưu file đã giải mã\r\n+            // Save decrypted file\r\n             String decryptedFilename = \"decrypted_\" + originalFilename.replace(\"encrypted_\", \"\");\r\n-            Path decryptedFile = uploadPath.resolve(decryptedFilename);\r\n+            decryptedFile = uploadPath.resolve(decryptedFilename);\r\n             Files.write(decryptedFile, decryptedContent);\r\n \r\n             model.addAttribute(\"message\", \"Giải mã thành công: \" + decryptedFilename + \r\n                 \" | Thời gian: \" + aes.getDecryptionTime() + \" ns\");\r\n             model.addAttribute(\"filePath\", decryptedFile.toAbsolutePath().toString());\r\n \r\n+        } catch (IOException e) {\r\n+            model.addAttribute(\"error\", \"Lỗi khi xử lý file: \" + e.getMessage());\r\n+            e.printStackTrace();\r\n         } catch (Exception e) {\r\n             model.addAttribute(\"error\", \"Lỗi khi giải mã: \" + e.getMessage());\r\n             e.printStackTrace();\r\n+        } finally {\r\n+            // Clean up temporary file\r\n+            if (tempFile != null && Files.exists(tempFile)) {\r\n+                try {\r\n+                    Files.delete(tempFile);\r\n+                } catch (IOException e) {\r\n+                    e.printStackTrace();\r\n+                }\r\n+            }\r\n         }\r\n         return \"index\";\r\n     }\r\n \r\n@@ -130,5 +193,21 @@\n             sb.append(chars.charAt(index));\r\n         }\r\n         return sb.toString();\r\n     }\r\n+\r\n+    private long parseMaxFileSize() {\r\n+        String size = maxFileSize.toUpperCase();\r\n+        long multiplier = 1;\r\n+        if (size.endsWith(\"KB\")) {\r\n+            multiplier = 1024;\r\n+            size = size.substring(0, size.length() - 2);\r\n+        } else if (size.endsWith(\"MB\")) {\r\n+            multiplier = 1024 * 1024;\r\n+            size = size.substring(0, size.length() - 2);\r\n+        } else if (size.endsWith(\"GB\")) {\r\n+            multiplier = 1024 * 1024 * 1024;\r\n+            size = size.substring(0, size.length() - 2);\r\n+        }\r\n+        return Long.parseLong(size) * multiplier;\r\n+    }\r\n }\n\\ No newline at end of file\n"
                }
            ],
            "date": 1743263565063,
            "name": "Commit-0",
            "content": "package com.example;\r\n\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.ui.Model;\r\nimport org.springframework.web.bind.annotation.*;\r\nimport org.springframework.web.multipart.MultipartFile;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\nimport java.io.IOException;\r\n\r\n@Controller\r\npublic class FileController {\r\n    private String secretKey;\r\n    private int keySize = 16; // Default to 128-bit\r\n    \r\n    @Value(\"${file.upload-dir}\")\r\n    private String uploadDir;\r\n\r\n    @GetMapping(\"/\")\r\n    public String home(Model model) {\r\n        model.addAttribute(\"key\", secretKey != null ? secretKey : \"Chưa có khóa\");\r\n        model.addAttribute(\"keySize\", keySize);\r\n        return \"index\";\r\n    }\r\n\r\n    @PostMapping(\"/generateKey\")\r\n    public String generateKey(@RequestParam(value = \"keySize\", defaultValue = \"16\") int size) {\r\n        keySize = size;\r\n        secretKey = generateRandomKey(keySize);\r\n        return \"redirect:/\";\r\n    }\r\n\r\n    @PostMapping(\"/setKey\")\r\n    public String setKey(@RequestParam(\"customKey\") String customKey, Model model) {\r\n        if (customKey.length() != 16 && customKey.length() != 24 && customKey.length() != 32) {\r\n            model.addAttribute(\"error\", \"Khóa phải có độ dài 16, 24 hoặc 32 ký tự\");\r\n            return \"index\";\r\n        }\r\n        secretKey = customKey;\r\n        keySize = customKey.length();\r\n        return \"redirect:/\";\r\n    }\r\n\r\n    @PostMapping(\"/encrypt\")\r\n    public String encryptFile(@RequestParam(\"file\") MultipartFile file, Model model) {\r\n        try {\r\n            if (secretKey == null) {\r\n                model.addAttribute(\"error\", \"Vui lòng tạo khóa trước!\");\r\n                return \"index\";\r\n            }\r\n\r\n            Path uploadPath = Paths.get(uploadDir);\r\n            if (!Files.exists(uploadPath)) {\r\n                Files.createDirectories(uploadPath);\r\n            }\r\n\r\n            String originalFilename = file.getOriginalFilename();\r\n            Path filePath = uploadPath.resolve(originalFilename);\r\n            file.transferTo(filePath);\r\n\r\n            // Đọc file và mã hóa\r\n            byte[] fileContent = Files.readAllBytes(filePath);\r\n            AES aes = new AES(secretKey);\r\n            String encryptedContent = aes.encryptFile(fileContent);\r\n            \r\n            // Lưu file đã mã hóa\r\n            String encryptedFilename = \"encrypted_\" + originalFilename;\r\n            Path encryptedFile = uploadPath.resolve(encryptedFilename);\r\n            Files.write(encryptedFile, encryptedContent.getBytes());\r\n\r\n            model.addAttribute(\"message\", \"Mã hóa thành công: \" + encryptedFilename + \r\n                \" | Thời gian: \" + aes.getEncryptionTime() + \" ns\");\r\n            model.addAttribute(\"filePath\", encryptedFile.toAbsolutePath().toString());\r\n\r\n        } catch (Exception e) {\r\n            model.addAttribute(\"error\", \"Lỗi khi mã hóa: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        }\r\n        return \"index\";\r\n    }\r\n\r\n    @PostMapping(\"/decrypt\")\r\n    public String decryptFile(@RequestParam(\"file\") MultipartFile file, Model model) {\r\n        try {\r\n            if (secretKey == null) {\r\n                model.addAttribute(\"error\", \"Vui lòng tạo khóa trước!\");\r\n                return \"index\";\r\n            }\r\n\r\n            Path uploadPath = Paths.get(uploadDir);\r\n            if (!Files.exists(uploadPath)) {\r\n                Files.createDirectories(uploadPath);\r\n            }\r\n\r\n            String originalFilename = file.getOriginalFilename();\r\n            Path filePath = uploadPath.resolve(originalFilename);\r\n            file.transferTo(filePath);\r\n\r\n            // Đọc file đã mã hóa\r\n            String encryptedContent = new String(Files.readAllBytes(filePath));\r\n            \r\n            AES aes = new AES(secretKey);\r\n            byte[] decryptedContent = aes.decryptFile(encryptedContent);\r\n            \r\n            // Lưu file đã giải mã\r\n            String decryptedFilename = \"decrypted_\" + originalFilename.replace(\"encrypted_\", \"\");\r\n            Path decryptedFile = uploadPath.resolve(decryptedFilename);\r\n            Files.write(decryptedFile, decryptedContent);\r\n\r\n            model.addAttribute(\"message\", \"Giải mã thành công: \" + decryptedFilename + \r\n                \" | Thời gian: \" + aes.getDecryptionTime() + \" ns\");\r\n            model.addAttribute(\"filePath\", decryptedFile.toAbsolutePath().toString());\r\n\r\n        } catch (Exception e) {\r\n            model.addAttribute(\"error\", \"Lỗi khi giải mã: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        }\r\n        return \"index\";\r\n    }\r\n\r\n    private String generateRandomKey(int length) {\r\n        String chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\r\n        StringBuilder sb = new StringBuilder();\r\n        for (int i = 0; i < length; i++) {\r\n            int index = (int) (Math.random() * chars.length());\r\n            sb.append(chars.charAt(index));\r\n        }\r\n        return sb.toString();\r\n    }\r\n}"
        }
    ]
}